// 2022-05-02
// [라이프 사이클과 스코프]

// 변수는 함수 => 스코프에 생김
// 1. 글로벌 스코프(전역 스코프)
//      애플리케이션이 실해되면 즉시 만들어지고 종료되면 그때 사라짐
// 2. 함수 스코프
//      함수를 통해 만들 수 있는 공간
//      함수 호출로 진입하면 스코프가 생기고
//      벗어나면 즉, 리턴되면 스코프가 사라진다.
// 3. 블록 스코프
//      코드를 묶고 있는 공간
//      블록이 만들어지고 그 블록 안으로 진입했을 때 생성되고
//      그 블록을 벗어나면 해당하는 스코프도 사라진다.

// 스코프 공간에 만들어진 변수나 함수는 그 스코프와 삶을 같이한다.

// 왜 이런 메카니즘이냐?
// 자바스크립트는 변수 하나, 함수 하나를 일일이 만들고 만들고
// 생성하고를 제어하지 않게 되어 있다.
// 스코프라고 하는 일종의 그룹핑 역할을 하는 공간으로 
// 그 라이프 사이클을 만들게 된다.

// 처음부터 만들어 놓고 끝까지 안 지우면?
// => 컴퓨터 시스템의 자원은 유한한 자원이므로 필요할 때만 사용하고 필요 없을 땐 버려지는 게
//      훨씬 효과적으로 적은 자원을 유용하게 쓸 수 있는 메카니즘이다.
//      그래서 그렇게 디자인되어 있는 것이다.

// 1. 전역 스코프
let myname = '박';

// 2. 함수 스코프
// foo() 스코프는 호출하고 진입할 때 생긴다.
// 함수가 리턴되면 사라진다.
// 스코프특징 - 중첩된다.
// 함수는 전역 스코프 < 함수 스코프
// 전역 스코프 안에 함수 스코프가 있다고 말할 수 있다.
// => 해당 함수 스코프는 전역 공간 안에 포함되어 있는 관계다.
function foo() {
    let x = 10;

    // 이럴경우 안쪽에 있는 스코프는 바깥쪽 스코프에 접근이 가능하다.
    console.log(myname);
    console.log(x);

    // 함수 스코프도 중첩시킬 수 있다.
    function bar(){
        let y = 10;

        console.log(x);
        console.log(myname);
    }

    // 바깥쪽에서 안쪽을 참조할 수 없다.
    console.log(y);
    bar();

    
}

foo();
// 함수가 리턴되면 사라지므로 foo안의 x를 바깥에서 접근할 수 없다.
console.log(x);

// 3. 블록스코프 
function foo2(){
    let x = 10;

    if(x === 10){
        let x = 100;
    
        // 스코프에서 변수를 찾을 땐 현재 자기 자신이 있는 스코프에서 찾고
        // 바깥쪽에서 찾고, 전역 스코프까지 찾는다.
        // (프로토타입과 비슷한 탐색 메카니즘을 갖고 있다.)
        console.log(x); // 100
    }
}

// -호이스팅
// 스코프가 생성될 때 그 스코프 안에 만들어야 될 변수나 함수들을 
// 미리 만들고 시작하는 것
// 실제 코드가 실행되기 전에 이 안에 코드를 탐색하고 만들 것들을
// 미리 만들어 놓은 다음에 코드를 실행시킨다.
// 함수 정의 문에서는 적용 가능하지만 함수 식에서는 적용되지 않는다.
function foo3(){
    
    bar(); // 호출 가능함.
    zoo(); // 호출 불가능 -> 함수 정의문이 아니라 함수 식이기 때문에 호이스팅 적용되지 않기 때문

    function bar(){
        let y = 10;

        console.log(x);
        console.log(myname);
    }

    const zoo = function(){
        console.log('zoo');
    }
    
}

// 만들어 놓고 사용하는 것이 안전한다.
// 변수, 함수 => 최상단에 만들어 놓고 그 이후에 사용하는 습관을 들이자.



