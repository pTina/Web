/*

2022-04-10
문법 - 함수

-함수의 역할
함수를 묶는 것
함수를 활용하기 위해 묶는 것
코드란? 계산을 하는 것
즉, 함수는 어떤 목적의 계산을 하는 코드의 묶음
계산을 필요 할  때 호출하는 과정을 통해 수행시킬 수 있음
-> 나온 결과를 받아볼 수 있는 문법 요소 => "함수"


*/

function myFn(){
    return 100;
}

const result = myFn();

/*
17번 ~21번 코드 실행 순서
기본적인 함수의 매커니즘

1. 함수를 만든다.
2. 함수가 호출된다.
3. 함수에 진입해서 계산한다.
4. 함수에서 값을 반환한다.
5. result에 반환 값을 할당한다.

*/

/* 

외부로부터 입력을 받는 값: 인자
괄호 안에 기술한다.
=> 가장 기본적인 형태

*/
// 값이 아닌 함수 정의문
// 세미콜론이 붙지 않음
function myFn(x){
    return x + 100;
}

const result = myFn(10); // 110

/*
자바스크립트의 함수는 유연성이 뛰어남
다양한 형태를 가지고 있음

1. 함수가 이름이 없을 수 있다. "이름 없는 함수, 익명 함수"

함수를 호출하는 방법: 이름을 가지고 호출함
=> 이름이 없으면? 함수를 호출할 수 없다.
=> 그럼 의미 없는거 아닌가?
자바스크립트는 언어 레벨에서 함수를 값으로 취급
값으로 취급한다 => 변수에 넣을 수 있다.

익명함수는 반드시 변수에 넣어야 사용할 수 있다.
*/

// myFnV2는 함수의 이름을 대신하게 된다.
// 함수를 값으로 취급하여 대입문으로 등장
// 값, 식 => 세미콜론으로 끝나야함
const myFnV2 = function () {
    return 10;
};

myFnV2();

/*
자바스크립트의 세미콜론은 자동으로 찍어줌
타이핑해주지 않아도 오류가 발생하지 않음

*/


/*

2. 즉시 실행 함수
함수가 만들어지자마자 즉시 한 번 실행한다.

실행하는 순간 값으로 취급해서 바로 호출하고 끝남.
두 번 다시 호출할 수 없는 함수
단 한 번만 실행시키는 함수

*/

(function() {
    console.log('eee');
})();

/*

*/

myFnV2.call();
myFnV2.apply();


/*

자바스크립트 함수의 호출 특징
함수가 인자를 1개만 받을거야 라고 만들어놔도
호출하는 쪽에서 1개 이상을 보내거나 1개미만을 보내도 호출이 성공함

함수가 어떻게 만들어져 있던지간에
이름이 같고 호출이라고 하는 문법만 맞으면
문제 없이 호출이 된다.
=> 인자 값이 없을 때, 더 많이 들어올 때를 대비해야 한다.
*/



// 가변 인자
function sum(a, b, c){
    return a+b+c;
}

sum(10, 20, 30);

/* 

2개, 4개, 5개를 줘도 다 더해주면 안되나~?

가변 인자일 때 처리 할 수 있는 방법 제공
1. arguments
    자바스크립트의 함수가 호출될 때 함께 전달되는 유사 배열
    호출 당시 넘겨 받은 인자들이 들어가 있음
*/

// 전달받은 인자를 arguments로 처리하기 때문git m에
// 인자를 기술할 필요 없음
function sum(){
    let total = 0;
    for(let i = 0; i<arguments.length; i++){
        total += arguments[i];
    }
    return total;
}

// 문제
// 함수 사용법, 관련된 정보(인자, ...)정보를 알 수 없으므로 매우 불편함
// *함수의 시그니처에 최대한 많은 정보를 표현해 주는 게 매우 중요함*
// arguments는 암묵적으로 작동되는 메커니즘 
// 함수의 시그니처에 등장시킬 수 있는 방법 없다. 표현력이 제한적이다.


// 2. 전개 파라미터 rest parameter
function sum(...args){
    let total = 0;
    for(let i = 0; i<args.length; i++){
        total += args[i];
    }
    return total;
}

// 함수 시그니처에 명시적으로 등장하는 방식
// => 가변 인자를 처리하는 함수라는 정보를 충분히 전달할 수 있다.
// 표현력이 높은 문법이다.
// function sum(a, b ...args){}
// => 3번째 인자부터 arguments에 들어감
// 훨씬 더 처리하기 쉽다.




/*
call, aplly

공통점: 첫 번째 인자로 context 객체를 받는다.
차이점
call: 인자를 일반 함수를 호출할 때 사용하는 방식 그대로 전달
apply는 인자를 배열에 담아서 전달해야한다.

*/

sum.call(null, 10, 20, 30);
sum.apply(null, [10, 20, 30]);

// 데이터를 이용한 인자 전달은 코드 자체를 바꾸지 않아도 된다는 장점이 있다.
// 함수의 호출에 인자 값을 외부로부터 공급받아
// 훨씬 더 유연하게 무언가를 할 때 그게 가능하게 호출되는 메커니즘
const arr = [10, 20, 30];
sum.apply(null, arr);


// 변형함수
// 1. 화살표 함수 (한 줄 함수)
// 기본값: 익명함수 => 이름을 줄 수 없음
// 그러므로 반드시 변수에 넣어 줘야 한다.

const sumV2 = (a,b, ...args) => {
    let total = 0;
    for(let i = 0; i<arguments.length; i++){
        total += arguments[i];
    }
    return total;
}

// 코드가 한 줄이고 그 코드가 리턴하는 값이라면 경우 브레이스를 생략할 수 있다.
const ten = () => 100;
const ten2 = (x) => 100+x;

// 인자가 1개일 때 괄호를 생략할 수 있다.
const ten3 = x => 100+x;



/*
2. 생성기 함수
generator function이라고 부름
function 키워드와 함수 이름 사이에 asterisk(*)아스트레이크를 붙인다.
통상적인 함수의 작동 방식과 완전히 다르다.

최초에 호출하면 함수가 실행되지 않고
실행 준비 상태로만 만든다.

객체 하나를 반환한다.
=> 함수가 실행될 준비를 마쳤다는 의미로 함수를 실행할 도구를 담은 객체를 반환한다.

=> 해당 객체를 가지고 함수를 실행했다가 멈췄다가 할 수 있다.

호출을 한 번 하고 여러 번 호출해서 그 함수가 종료되지 않았는데
다시 들어갔다가 다시 나오고의 동작을 할 수 있다.

*/

function* gen() {
    yield 10;
    yield 20;
    return 30;
}

// 제러네이터 함수가 반환하는 객체에는 next 메소드가 포함되어 있다.
const g = gen();
g.next();
g.next();
g.next();

/*
어떤 커뮤니케이션이 가능한가?
1. 값 전달
2. 값 전달 받기
보통 값을 전달 받을 때 함수에서 return 키워드를 쓰는데 제너레이터 함수에서는 yield 키워드를 사용할 수 있다.

제너레이터 함수는 실행을 잠시 중단시켰다가
next함수의 호출로 안쪽으로 들어와서 실행을 재개시킬 수 있다.
*/

// 3. 비동기함수
// promise의 비동기 코드 구성을 동기적으로 코드를 작성할 수 있게 만들어주는 스펙
async function myTask(){

}



/**/
/**/
/**/